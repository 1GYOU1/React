# redux 

1. 상태가 어떠한 변화가 필요하면 액션(action)이란 것을 발생한다.
이것은 하나의 객체로 표현되는데 액션 객체는 
{
	type:'TOGGLE_VALUE'
}
2. 액션 생성 함수 
function add(data){
return{
	type:'ADD",
	data:{
		id:1,
		text:'첫번째 글'
	}
}
}

const add = a =>(
	{
		type:'ADD",
		data
	}
)

3. reducer 는 변화를 일으키는 함수. 
액션을 만들어서 발생시키면 리듀서가 현재 상태와 전달받은 액션 객체를 파라미터로 받아온다. 그리고 두 값을 참고하여 새로운 상태를 만들어서 반환해 준다. 
const initialState={
  counter:1
};
function reducer(state = initialState, action){
  switch(action.type){
    case INCREMENT:
      return{
        counter:state.counter +1
      };
    default:
      return state;
  }
}

4. store : 프로젝트에 리덕스를 적용하기 위해서는 단하나의 스토어를 만들어야 한다.
스토어 안에는 현재 애플리케이션 상태와 리듀서가 들어가 있으며 그 외 중요한 내장함수를 지닌다.

5. dispatch : store의 내장함수. 액션을 발생시키는 함수
dispatch(action)

6. subscribe(구독) : store의 내장함수. 
subcribe의 파마리터로 넣어서 호출해주면 이 리스너 함수가 액션이 디스패치되어 상태가 업데이트 될때마다 호출된다. 
const listener = () =>{
		console.log('업데이트');
}
const unsubscribe = store.subscribe(listener);
unsubscribe();

---------------------------------------------------------------------------
https://ko.parceljs.org/getting_started.html

mkdir vailla-redux
cd vailla-redux
yarn global add parcel-bundler
package.json 파일 생성 
yarn init -y 또는 npm init -y

yarn add parcel-bundler
yarn parcel index.html

yarn add redux

object.something.inside.value


------------------------------------------------------------------------
# 리덕스의 세가지 규칙
1. 단일 스토어
2. 읽기 전용 상태(불변유지를 위해) : 객체의 변화를 감지 할때 객체의 깊숙한 안쪽까지 비교하는 것이 아니라 겉핥기 식으로 비교하여 좋은 성능을 유지할수 있다.
3. 리듀서는 순수한 함수 (변화를 일으키는 리듀서 함수는 순수한 함수)
- 리듀서 함수는 이전 상태와 액션 객체를 파라미터로 받는다
- 파라미터 외의 값에는 의존하면 안된다
- 이전 상태는 절대로 건드리지 않고, 변화를 준 새로운 상태 객체를 만들어서 반환한다
- 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과 값을 반환해야 한다.


----------------------------------------------------------------------------------
yarn create react-app react-redux
yarn add redux react-redux
yarn add redux-devtools-extension

상태 업데이트에 관한 로직을 모듈로 따로 분리하여 컴포넌트 파일과 별개로 관리할 수 있으므로 코드 유지 보수하는데 도움이 된다.
여러 컴포넌트에서 동일한 상태를 공유해야 할때 매우 유용.
실제 업데이트가 필요한 컴포넌트만 리렌더링 되도록 쉽게 최적화 해 줄 수도 있다.

store.dispatch, store.subscribe 
리액트 애플리케이션(react-redux)에서 제공하는 유틸함수(connect)와 컴포넌트(Provider)를 사용하여 리덕스 관련 작업 처리.


프레젠테이셔널 컴포넌트와 컨테이너 컴포넌트를 분리하는것.
여기서 프레젠테이셔널 컴포넌트란 주로 상태 관리가 이루어지지 않고 그저 props를 받아 와서 화면에 UI를 보여 주기만 하는 컴포넌트를 말한다.
컨테이너 컴포넌트는 리덕스와 연동되어 있는 컴포넌트로 리덕스로 부터 상태를 받아오기도 하고 리덕스 스토어에 액션을 디스패치하기도 한다. 

UI에 관련된 프레젠테이셔널 컴포넌트 src/components 저장
리덕스와 연동된 컨테이너 컴포넌넌트 src/containers 저장.


일반적인 구조 
actions
constants
reducers 


Ducks 패턴 
액션타입, 액션생성함수, 리듀서 함수를 기능별로 파일 하나에 몰아서 다 작성 하는 방식으로 작성하는 코드를 모듈 이라고 한다. 

import counter from './counter';
import {increase, decrease} from './counter';
// 한꺼번에 불러오고 싶을때
import counter, {increase, decrease} from './counter';

index.js가 modules 디렉터리의 루트파일이 돼서 가능하다.
import rootReducer from './mdules';

<Provider : 리액트 컴포넌트에서 스토어를 사용할수 있도록 App 컴포넌트를 react-redux에서 제공하는 컴포넌트. 
이 컴포넌트를 사용할때는 store를 props로 전달해 주어야 한다. 

react-redux에서 제공하는 리덕스와 연동하기 위한 유틸함수.
connect(mapStateToProps, mapDispatchToProps) 


const makeContainer = connect(mapStateToProps, mapDispatchToProps) 
makeContainer(타깃 컴포넌트)
-----------------------------------------------------------------------------------

액션생성함수를 더 짧은 코드로 작성할수 있다. 
yarn add redux-actions 

switch.case -> handleActions 함수를 사용하여 각 액션마다 업데이트 함수를 설정할는 형식으로 작성할수있다. 


const counter = handleActions( 
    {
        [INCREASE]:(state, action) =>({ number: state.number +1}),
        [DECREASE]:(state, action) =>({ number:state.number -1})
    },
    initialState,
)
// 첫번째 파라미터는 액션에 대한 업데이트함수를 넣어주고
두번째 파라미터는 초기 상태를 넣어준다. 

// ceateAction으로 액션을 만들면 액션에 필요한 추가 데이터는 payload라는 이름을 사용한다. 
const MY_ACTION = 'sample/MY_ACTION';
const myAction = createAction(MY_ACTION);
const action= myAction('hello world');
/* 결과
{ type: MY_ACTION, payload: 'hello world'}
*/

// 액션생성 함수에서 받아온 파라미터를 그대로 payload에 넣는 것이 아니라
변형을 주어서 넣고 싶다면 createAction의 두번째 함수에 payload를 정의하는  함수를 따로 선언해서 넣어주면 된다. 
const MY_ACTION = 'sample/MY_ACTION';
const myAction = createAction(MY_ACTION, text => `${text}!`);
const action= myAction('hello world');
/* 결과
{ type: MY_ACTION, payload: 'hello world!'}
*/

------------------------------------------------
immer : 리듀서에서 상태를 업데이트할때 불변성을 지켜야 하기 때문에 spread연산자와 배열의 내장함수를 활용한다. 그러나 모듈의 상태가 복잡해질수록 불변성을 지키기가 어렵다. 

yarn add immer
















