# React.js

### 2022-12-11

### 시간표<br>

10:10 ~ 11:00<br>
11:10 ~ 12:00<br>
12:10 ~ 13:00<br>
13:00 ~ 13:40 점심시간 <br>
13:40 ~ 14:30<br>
14:40 ~ 15:30<br>
15:40 ~ 16:30<br>
16:40 ~ 17:30

2일 결근 가능

---

## React 특징

- html css javascript 기본으로 사용.
- 6주부터는 포폴 완성될 수 있도록 커리큘럼 짜여짐.
- javascript ES6 언어 기반으로 만들어짐.
- 서버연결 때문에 디렉토리 경로 네이밍은 대부분 소문자로 통일.
- ES6를 사용하여 리액트 네이티브, 여러가지 프레임 워크를 사용할 수 있는 확장성이 큼.
- 라이브러리 방식. 어딘가에 끼워 넣는 방식으로 필요 없으면 해당 부분만 빼낼 수 있음.
- npm 패키지
- React를 사용하는 가장 큰 이유는 <b>성능 최적화 최고 효율</b>로 만들기 위해서 사용.
- 무조건적 사용 X. node.js 용량이 큼.
- 정적인 페이지와는 맞지 않다.
- 무조건 node.js 설치되어있어야함.

참고 사이트

- [ES6 문법](https://hanamon.kr/javascript-es6-%EB%AC%B8%EB%B2%95/)
- [에어비앤비 사이트](https://www.airbnb.co.kr/)
- [jsbin - javascript console 사용해보는 사이트](https://jsbin.com/?html,output)

<br>

**일반적인 엘리먼트 불러오기** 방식

- 랜더링(사용자한테 보여주는 것) -> HTML(마크업) -> DOM 도큐먼트 객체(문서영역) 찾아서 읽기
- 일반적인 엘리먼트 읽는 법은 MVC(Model->View->Controler(사용자))기반

<br>

**React** 불러오는 방식

- 유지보수 안정화때문에 인기가 많음.
- 변경이 필요한 데이터만 랜더링을 따로 줌.(일반적인 방식으로 처음부터 타고 올라오지 않아도 됨.)
- 메모리를 아낄 수 있음.
- MVC 중 View만 신경쓰면 됨.
- 영역을 component 조각으로 만들어서 재사용가능.

<br>

### 프레임워크와 라이브러리 차이

- 프레임워크 - 형식(틀)이 정해져있음. 해당 환경만 이해하면 됨.
- 라이브러리 - 형식이 자유롭지만, 추가적인 환경을 모두 이해해야함.

### API

- 잘 만들어 놓은 동작, 기능들 (ex: 카카오 위치기반 주소검색기능, 구글 통계, 구글 지도 API)
- 위젯처럼 독립적으로 소스를 붙이거나 설치

  Plug-in - 프로그램에 종속되어 설치해서 사용. 다른 프로그램에서는 사용 X

  Module - 개별 프로그램의 작은 단위

참고사이트

[API Plug-in Module 차이점](http://www.theprconsulting.com/?p=2842)

<br>

### 랜더링

```js
render(){...} //함수
```

초기 랜더링

- 전체 불러오기

리 랜더링

- 변한 부분만 변경

<br>

### 일반적으로 사용하는 DOM 특징

- 자체는 빠르나 소스를 불러오는 과정들이 필요함.
- document object model - 객체. 객체로 문서 구조를 표현하는 방법 (xml, html)
- DOM에 자바스크립트 적용
- 트리형태의 구조
- 단점 : 정적인 언어 html -> 동적이지않아서 변경된 부분 감지X

### React 사용하는 virtual dom - 가상 돔

실제로 DOM을 만들지 않고 가상 돔을 만듬.

1. 데이터를 업데이트하면 전체 ui를 virtual dom에 리렌더링 한다.
2. 이전 virtual dom에 있던 내용과 현재 내용을 비교
3. 바뀐 부분만 실제 dom에 적용.

<br>

## babel

- ES6 -> ES5 변환(크로스브라우징 때문에 상위버전으로 하위버전으로 변환)

- 모듈화된 코드를 한 파일로 합치는(번들링) 코드를 수정할 때마다 웹 브라우저를 리로딩하는 등의 기능을 하는 웹팩(Webpack)

<br>

## node.js

### npm

- node 패키지 매니저 도구
- npm으로 개발자가 만든 패키지 (재사용 가능한 코드)
- 패키지의 버전을 관리할 수도 있다.

[node.js 설치](https://nodejs.org/ko/download/) (LTS 버전 설치)

node.js 설치 확인

> $ node -v

mac ios, 또는 리눅스를 사용하는 환경 cmd에 입력하여 확인

> $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash

맥, 윈도우 상관없이 통합적으로 확인

터미널

> $ nvm —version

<br>

## yarn

- npm을 대체할 수 있는 도구
- npm보다 빠르고 효율적으로 캐시시스템, 기타 부가기능을 제공.

yarn 설치

> $ npm install —global yarn

yarn 버전 확인

> $ yarn --version

[yarn 설치 참고사이트](https://classic.yarnpkg.com/en/docs/install#windows-stable)

<br>

## vscode 도구 설치

### ESLint

자바스크립트 문법 및 코드 스타일을 검사해주는 도구

### Reactjs code snippets

publisher:"charalampos karypidis"

리액트 컴포넌트 및 라이프 사이클 함수를 작성할때 단축단어를 사용하여 간편하게 코드를 자동 생성 할 수 있는 코드 스니펫 모음.

### prettier-code formatter

코드 스타일을 자동으로 정리해주는 도구.

### korean language pack for visual astudio code

한국어

<br>

## git bash, yarn

협업 도구

[mac(ios) download link](https://git-scm.com/download/mac)

[window download link](https://git-scm.com/download/)

Download for Windows > Standalone Installer > 64-bit Git for Windows Setup.

git bash 를 사용하면 mac과 window에서 동일하게 사용가능.

<br>

vscode 터미널 git bash 창에 입력

> $ yarn create react-app hello-react

[React 프로젝트 작업 환경 구성 및 시작하기](https://chanhuiseok.github.io/posts/react-2/)

cmd 입력 버전

> $ npm create-react-app hello-react

> $ yarn create-react-app hello-react

<br>

다음 과정

> $ cd hello-react

> $ yarn start

http://localhost:3000/

---

## package.json

- 설치 버전 중요 ★★★★★

- 16버전 이전은 함수로 이루어져 있고, 16이상은 객체 컴포넌트로 이루어져 있음.

- 버전 충돌 주의

{ } 중괄호로 이루어져있어, 객체인 것을 알 수 있음.

```json
  "dependencies": {
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^13.0.0",
    "@testing-library/user-event": "^13.2.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.0"
  },
```

### npm의 장단점

- npm은 배포가 쉽고 종속성을 쉽게 해결할 수 있다는 장점이 있지만 패키지가 중복으로 설치될 수 있다는 단점이 있다.
- node_modules를 관리하면서의 불편한 점을 개선하기 위해 Yarn이 탄생

[npm / npx / yarn](https://hanamon.kr/npm-npx-%ec%b0%a8%ec%9d%b4/)

---

## react.js\hello-react\src\App.js

```js
import logo from "./logo.svg"; //nodemodule이 있어서 가능한 부분
import "./App.css";

function App() {
  return (
    //return : 내부에서 사용하는 내용을 외부에서도 사용가능하도록 내보내기.
    //React에서는 className 이라는 클래스를 사용.
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;
```

parcle

jsx(javascript Xml) 문법 : 정식 자바스크립트 문법이 아니기 때문에 ES5 자바스크립트의 형태로 변환해야함.

jsx 문법 예시 ↓↓

```js
<div className="App">
  <header className="App-header">
    <img src={logo} className="App-logo" alt="logo" />
    <p>
      Edit <code>src/App.js</code> and save to reload.
    </p>
    <a
      className="App-link"
      href="https://reactjs.org"
      target="_blank"
      rel="noopener noreferrer"
    >
      Learn React
    </a>
  </header>
</div>
```

ecmascript2015(ES6)

2016 ES7

## react.js\hello-react\src\index.js

```js
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  //변화를 감지하여 랜더링 시키는 함수.
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

## react.js\hello-react\public\index.html

```html
<div id="root"></div>
<!--React 영역-->
```

## react.js\hello-react\src\App.js

### 호이스팅 문제

호이스팅을 설명할 땐 주로 "변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮기는" 것

var로 선언한 변수의 경우 호이스팅 시 undefined로 변수를 초기화

```js
console.log(a); //undefined
var a = 1;
```

let과 const로 선언한 변수의 경우 호이스팅 시 변수를 초기화하지 않음.

```js
console.log(a); //error
let a = 1;
```

조건 ? 참 : 거짓

- name이 참일때만 True 노출 아니면 노출 X
- true = 1
- false = 0
- falsy 값인 0은 예외적으로 화면에 출력된다.

```js
function App() {
  const name = "1GYOU1";
  return (
    <>
      {name === "1GYOU1" && <h1>True</h1>}
      {/*True 출력*/}
    </>
  );
}
export default App;
```

```js
function App() {
  const number = 0;
  return (
    <>
      {number && <h1>True</h1>}
      {/*0 출력*/}
    </>
  );
}
export default App;
```

React에서 undefined를 단독 사용하지 않는 것 권장.
사용하고 싶으면 or를 같이 사용할 것.

```js
function App() {
  const name = undefined;
  return name || "값이 undefined 입니다.";
  {
    /*값이 undefined 입니다. 출력*/
  }
}
export default App;
```

<br>

내부css 사용하여 스타일 적용

```js
function App() {
  const name = '리액트';
  const style = {
    backgroundColor: 'black',
    color: 'aqua',
    fontSize: '48px',
    fontWeight: 'bold',
    padding: 16,{/*px이 기본값, but 정확하게 표기해주는 것을 권장*/}
  };
  return <div style={style}>{name}</div>
}
export default App;
```

<br>

css 파일 import 해서 적용하기

```js
import "./App.css";

function App() {
  const name = "리액트";
  return <div className="react">{name}</div>;
}
export default App;
```

```css
.react {
  background-color: pink;
  color: lightgoldenrodyellow;
  font-size: 48px;
  font-weight: "bold";
  padding: 16px;
}
```

return 안에서 주석 작성법

```js
import "./App.css";

function App() {
  //함수형 컴포넌트

  const name = "리액트";
  //주석은 이렇게 작성합니다

  return (
    <div className="react">
      {name}
      {/*주석은 이렇게 작성합니다*/}
      <input />
    </div>
  );
}

export default App;
```

---

## .prettierrc

작은 따옴표, 큰 따옴표 또는 탭 사용 칸 개수, 세미콜론 무조건 붙이기 등 저장시에 통일 시켜주는 파일

1. .prettierrc 파일 생성 (.gitignore와 같은 폴더 안에 위치)

2. VS Code 에서
   ctrl+, 단축키 (설정)에 들어가서
   검색에 Default Formatter
   Prettier - code formatter 로 변경 후
   VSCode 끄고 다시 키기
3. Format on Save 확인 > vscode 설정에서 format on save를 입력하고 나오는 설정에 체크되어 있는 지 확인한다.

[prettier 참고](https://prettier.io/docs/en/options.html)

---

## .prototype

ES5 문법

[프로토타입과 클래스](https://learnjs.vlpt.us/basics/10-prototype-class.html)

<br>

함수형 컴포넌트의 장점

- 클래스형보다 선언하기가 쉽다.
- 메모리자원을 클래스형보다 덜 사용. 속도가 빠르다.
- 프로젝트를 완성하여 빌드한 후 배포할 때도 함수 컴포넌트를 사용하는 것이 결과물 파이링 더 작다.

단점

- API를 끌어다가 오는 것이 번거로움

```js
function Dog(name) {
  this.name = name;
}
//Dog.원형.say라는 속성 추가
Dog.prototype.say = function () {
  console.log(this.name + " : 멍멍");
};
const dog = new Dog("흰둥이");
dog.say(); //흰둥이 : 멍멍
```

<br>

---

### 화살표 함수와 일반함수에서의 this 차이

화살표함수, react에서는 this를 잘 사용 X

최상위 객체에 접근 X (보안성이 떨어짐)

<br>

일반 함수에서의 this 사용

- 자신을 감싸고 있는 객체 전체를 가리킴
- 자신이 종속된 객체를 this로 가리킴

```js
function BlackDog() {
  this.name = "흰둥이";
  return {
    name: "검둥이",
    bark: function () {
      console.log(this); //{name: '검둥이', bark: ƒ}
      console.log(this.name + ": 멍멍");
    },
  };
}
const blackDog = new BlackDog(); //인스턴스(new ~~ 새롭게 추가가능)
blackDog.bark(); //검둥이: 멍멍
```

화살표 함수에서의 this

- 자신을 감싸고 있는 인스턴스를 가리킴
- 자신이 종속된 인스턴스 new로 생성된 생성자 객체를 가리킨다.

```js
function WhiteDog() {
  this.name = "흰둥이";
  return {
    name: "검둥이",
    bark: () => {
      console.log(this); //WhiteDog {name: '흰둥이'}
      console.log(this.name + ": 멍멍"); //흰둥이: 멍멍
    },
  };
}
const whiteDog = new WhiteDog();
whiteDog.bark();
```
